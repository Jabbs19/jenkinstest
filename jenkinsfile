def label = "jenkins-slave-${UUID.randomUUID().toString()}"
//Production Variables
def PRD_OS_PROJECT = "psd-helpline-prd"
def PRD_IMAGE_TAG = "production"
def PRD_HELM_VALUES_LOC = "helm/helpline/values-prd.yaml"

//Release Variables
def REL_OS_PROJECT = "psd-helpline-rel"
def REL_IMAGE_TAG = "release"
def REL_HELM_VALUES_LOC = "helm/helpline/values-rel.yaml"

//Develop Variables
def DEV_OS_PROJECT = "psd-helpline-tst"
def DEV_IMAGE_TAG = "test"
def DEV_HELM_VALUES_LOC = "helm/helpline/values-tst.yaml"

//Stage Variables
def STG_OS_PROJECT = "psd-helpline-stg"
def STG_IMAGE_TAG = "feature"
def STG_HELM_VALUES_LOC = "helm/helpline/values.yaml"

//HotFix Variables (Not all needed unless deploying.)
//def HOT_OS_PROJECT = "psd-helpline-hot"
def HOT_IMAGE_TAG = "hotfix"
//def HOT_HELM_VALUES_LOC = "helm/helpline/values-hot.yaml"

//Git Variables
def REL_TAG_FILTER="release-m-"
def HOT_TAG_FILTER = "hotfix-m-"

//Image Variables
def IMAGE_NAME = "helpline"

//Helm and Tiller Stuff
def HELM_TILLER_NAMESPACE = 'ocp-tiller'
def HELM_CHARTNAME = 'helpline'
def HELM_CHART_LOCATION = 'helm/helpline'
def HELM_TGZ_DEST_DIR = 'helm'

//Global "to-be-assigned" Variables
def IMAGE_BUILD_OS_PROJECT = ""     //OpenShift Project (aka Repo) (e.g. psd-helpline-tst)
def IMAGE_BUILD_TAG = ""            //Tag Name for Image (e.g. :test
def IMAGE_BUILD_FULL_NAME = ""      //Full Image Name Image (e.g. psd-hepline-tst/helpline:test) 
def IMAGE_BUILD_SECONDARY_TAG = ""  //Additional tags to be applied after Build
def DEPLOY_IMAGE_TAG = ""
def DEPLOY_IMAGE_NAME = ""
def DEPLOY_OS_PROJECT = ""          //Project that the image will be pulled from for deployment.
def RELEASE_TYPE = ""               //Branch name, with tags mapped to an easy-to-read name (e.g. release, hotfix)
def GIT_COMMIT_HEAD_TAG = ""
def GIT_SHORT_COMMIT = ""
def HELM_RELEASE_NAME_FINAL = ""
def HELM_YAML_LOCATION_FINAL = ""
def HELM_TGZ_PACKAGE_FINAL = ""
def APP_VERSION = ""
def HELM_CHART_VERSION = ""

      //Project that image will be built/tagged to.

podTemplate(
    label: label,
    cloud: "openshift",
    containers: [
        containerTemplate(name: 'maven', image: 'maven:alpine', ttyEnabled: true, command: 'cat'),
        containerTemplate(name: 'golang', image: 'golang:alpine', ttyEnabled: true, command: 'cat'),
        containerTemplate(name: 'helm', image: 'docker-registry.default.svc:5000/openshift/helm:2.14.0', ttyEnabled: true, command: 'cat'),
        containerTemplate(name: 'openshift', image: 'docker-registry.default.svc:5000/openshift/openshift-cli', ttyEnabled: true, command: 'cat'),
        containerTemplate(name: 'docker', image: 'docker', ttyEnabled: true, command: 'cat'),
        containerTemplate(name: 'ruby', image: 'ruby:2.5.5', ttyEnabled: true, command: 'cat')

    
    ]
) {
    node(label) {
        stage('Init') {
          sh """
            pwd
            env
            find ${HOME}
            df -h
            """
        }
        container('jnlp') {
            stage('SCM Checkout') {
                checkout scm
                GIT_COMMIT_HEAD_TAG = sh(returnStdout: true, script: "git tag -l --points-at HEAD | tail -1").trim()
                echo 'Commit Head Tag:' + GIT_COMMIT_HEAD_TAG
                echo 'Current Branch Name:' + env.BRANCH_NAME
                //Build "App Version"
                if (GIT_COMMIT_HEAD_TAG != "") {
                    if (GIT_COMMIT_HEAD_TAG.substring(0,REL_TAG_FILTER.length()) == REL_TAG_FILTER) {
                        APP_VERSION = GIT_COMMIT_HEAD_TAG.substring(REL_TAG_FILTER.length(),GIT_COMMIT_HEAD_TAG.length())
                    } else if (GIT_COMMIT_HEAD_TAG.substring(0,HOT_TAG_FILTER.length()) == HOT_TAG_FILTER) {
                        APP_VERSION = GIT_COMMIT_HEAD_TAG.substring(HOT_TAG_FILTER.length(),GIT_COMMIT_HEAD_TAG.length())
                    } else {
                        APP_VERSION = ""
                    }
                    echo 'App Version Parsing Complete (if needed): ' + APP_VERSION
                }
                GIT_SHORT_COMMIT = sh(returnStdout: true, script: "git rev-parse --short HEAD | tail -1").trim()

            }
            stage('Set Branch Variables') {
                echo 'Set Branch Variables Branch:'
                if (env.BRANCH_NAME == 'master') {
                    echo 'Executing on Master'
                    RELEASE_TYPE = 'master'
                    DEPLOY_OS_PROJECT = PRD_OS_PROJECT
                    DEPLOY_IMAGE_TAG = APP_VERSION
                    DEPLOY_IMAGE_NAME = DEPLOY_OS_PROJECT + '/' + IMAGE_NAME + ':' + DEPLOY_IMAGE_TAG
                    HELM_RELEASE_NAME_FINAL = HELM_CHARTNAME + '-prd'
                    HELM_YAML_LOCATION_FINAL = PRD_HELM_VALUES_LOC
                    //Tags for Master Release Checks.  Could add more filters, sig checks, etc.
                    if (GIT_COMMIT_HEAD_TAG == "") {
                        error "No Git Version at Master Head"
                    } 
                } else if (env.BRANCH_NAME == 'develop'){
                    echo 'Execute on Develop'
                    RELEASE_TYPE = 'develop'
                    IMAGE_BUILD_OS_PROJECT = DEV_OS_PROJECT
                    IMAGE_BUILD_TAG = DEV_IMAGE_TAG
                    DEPLOY_OS_PROJECT = DEV_OS_PROJECT
                    DEPLOY_IMAGE_TAG = DEV_IMAGE_TAG
                    HELM_YAML_LOCATION_FINAL = DEV_HELM_VALUES_LOC
                    HELM_RELEASE_NAME_FINAL = HELM_CHARTNAME + '-dev'

                } else if (env.BRANCH_NAME == 'stage'){
                    echo 'Execute on Stage'
                    RELEASE_TYPE = 'stage'
                    IMAGE_BUILD_OS_PROJECT = STG_OS_PROJECT
                    IMAGE_BUILD_TAG = STG_IMAGE_TAG
                    DEPLOY_OS_PROJECT = STG_OS_PROJECT
                    DEPLOY_IMAGE_TAG = STG_IMAGE_TAG
                    HELM_YAML_LOCATION_FINAL = STG_HELM_VALUES_LOC
                    HELM_RELEASE_NAME_FINAL = HELM_CHARTNAME + '-stg'

                } else if (env.BRANCH_NAME.contains(REL_TAG_FILTER) && GIT_COMMIT_HEAD_TAG.contains(REL_TAG_FILTER)){
                    echo 'Execute on specific "Release" Tag of:' + REL_TAG_FILTER
                    RELEASE_TYPE = 'release'
                    IMAGE_BUILD_OS_PROJECT = REL_OS_PROJECT
                    IMAGE_BUILD_TAG = REL_IMAGE_TAG
                    DEPLOY_OS_PROJECT = REL_OS_PROJECT
                    DEPLOY_IMAGE_TAG = APP_VERSION
                    HELM_YAML_LOCATION_FINAL = REL_HELM_VALUES_LOC
                    HELM_RELEASE_NAME_FINAL = HELM_CHARTNAME + '-rel'

                    if (GIT_COMMIT_HEAD_TAG == "") {
                        error "No Git Version at Commit Head"
                    } 

                } else if (env.BRANCH_NAME.contains(HOT_TAG_FILTER) && GIT_COMMIT_HEAD_TAG.contains(HOT_TAG_FILTER)){
                    echo 'Execute on specific "HotFix" Tag of:' + HOT_TAG_FILTER
                    RELEASE_TYPE = 'hotfix'
                    IMAGE_BUILD_OS_PROJECT = REL_OS_PROJECT
                    IMAGE_BUILD_TAG = HOT_IMAGE_TAG
                    DEPLOY_OS_PROJECT = REL_OS_PROJECT                  //Doesn't actually deploy.
                    DEPLOY_IMAGE_TAG = APP_VERSION
                    HELM_YAML_LOCATION_FINAL = PRD_HELM_VALUES_LOC
                    HELM_RELEASE_NAME_FINAL = HELM_CHARTNAME + '-hot'  //Doesn't actually deploy or use helm.
                    if (GIT_COMMIT_HEAD_TAG == "") {
                        error "No Git Version at Commit Head"
                    } 

                }
                else {
                    echo 'Non Branch or Tag execution.'
                    echo 'Head Tag:' + GIT_COMMIT_HEAD_TAG
                    echo 'Branch Name:' + env.BRANCH_NAME
                    error 'Non Branch or Tag execution.'
                }

                //Print Variables for Logging.
                echo 'Display Some Variables for Logging'
                echo 'Branch Name:' + env.BRANCH_NAME
                echo 'Git Tag: ' + GIT_COMMIT_HEAD_TAG
                echo 'Commit Short Hash: ' + GIT_SHORT_COMMIT
                echo 'Release Type: ' + RELEASE_TYPE
                echo 'Build Project: ' + IMAGE_BUILD_OS_PROJECT
                echo 'Build Image Name: ' + IMAGE_BUILD_OS_PROJECT + '/' + IMAGE_NAME + ':' + IMAGE_BUILD_TAG
                echo 'Deploy Project: ' + DEPLOY_OS_PROJECT
                echo 'Deploy Image Name: ' +  DEPLOY_OS_PROJECT + '/' + IMAGE_NAME + ':' + DEPLOY_IMAGE_TAG
                echo 'Parsed App Version (If Applicable): ' + APP_VERSION
            }
        }
        stage('Unit Test') {
            container('ruby') {
                if (RELEASE_TYPE == 'master') {
                    echo 'No Unit Test'
                } else if (RELEASE_TYPE == 'develop'){
                    echo 'No Unit Test'
                } else if (RELEASE_TYPE == 'stage'){
                    echo 'No Unit Test'
                } else if (RELEASE_TYPE == 'release'){
                    echo 'Execute Unit Tests'
                    sh """
                    ruby -v
                    """
                    /* Real Code
                    withCredentials([string(credentialsId: 'psd-rails-master-key', variable: 'RAILS_MASTER_KEY')]) {
                        container('ruby') {
                          sh """
                            bundle install
                    printenv
                            rake db:create RAILS_ENV=test
                            rake db:migrate RAILS_ENV=test
                    printenv
                            RAILS_MASTER_KEY=${RAILS_MASTER_KEY} rake db:test:prepare
                            RAILS_MASTER_KEY=${RAILS_MASTER_KEY} rspec
                            """
                        }
                    }
                    */
                } else if (RELEASE_TYPE == 'hotfix'){
                    echo 'No Unit Test'
                } 
            }
        }
        stage('Checkmarx') {
            container('jnlp') {
                if (RELEASE_TYPE == 'master') {
                    echo 'No Checkmarx'
                } else if (RELEASE_TYPE == 'develop'){
                    echo 'No Checkmarx'
                } else if (RELEASE_TYPE == 'stage'){
                    echo 'No Checkmarx'
                } else if (RELEASE_TYPE == 'release'){
                    echo 'Execute Checkmarx'
                } else if (RELEASE_TYPE == 'hotfix'){
                    echo 'No Checkmarx'
                } 
            }
        }
        
        container('openshift') {
            stage('Create Secrets') {

            // Will need to create uniqu credentials for all environments that have unique values.
            // e.g. dev-rails-master-key, stg-rails-master-key, prd-rails-master-key, rel-rails-master-key

            /*withCredentials([
                string(credentialsId: 'psd-rails-master-key', variable: 'RAILS_MASTER_KEY'),
                string(credentialsId: 'psd-helpline-database-password-tst', variable: 'DATABASE_PWD'),
                string(credentialsId: 'psd-helpline-keybase', variable: 'KEYBASE')
                ]) {
                    
                    //Put all of the If else in here.
                    }
            */
            //Fake Data:
                def RAILS_MASTER_KEY = 'rails-master-key-14njfgaht3q3tj'
                def DATABASE_PWD = 'hereismydbapassword'
                def KEYBASE = '75q05704319750914375093475070134901'

                if (RELEASE_TYPE == 'master') {
                    //No Build secret, just Application/Deployment Secret
                    echo '1. Delete All Secrets in PRD. 2. Create Application Secrets in PRD.'
                    sh """
                    echo 'oc project ${DEPLOY_OS_PROJECT}'
                    echo 'oc delete secret "bt-helpline-secret" -n ${DEPLOY_OS_PROJECT}'
                    echo 'oc create secret generic bt-helpline-secret --from-literal=database-password="${DATABASE_PWD}" --from-literal=keybase="${KEYBASE}"'
                    """ 
                } else if (RELEASE_TYPE == 'develop' || \
                    RELEASE_TYPE == 'stage' || \
                    RELEASE_TYPE == 'release' || \
                    RELEASE_TYPE == 'hotfix') {
                    //Both Build and Application/Deployment Secret
                    
                    echo '1. Delete All Secrets in TST. 2. Create Image build secretsin TST. 3. Create Application Secrets in TST.'
                    sh """
                    echo 'oc project ${BUILD_OS_PROJECT}'
                    echo 'oc delete secret "bt-helpline-secret-rails" -n ${IMAGE_BUILD_OS_PROJECT}'
                    echo 'oc create secret generic bt-helpline-secret-rails --from-literal=RAILS_MASTER_KEY="${RAILS_MASTER_KEY}"'
                    """

                    sh """
                    echo 'oc project ${DEPLOY_OS_PROJECT}'
                    echo 'oc delete secret "bt-helpline-secret" -n ${DEPLOY_OS_PROJECT}'
                    echo 'oc create secret generic bt-helpline-secret --from-literal=database-password="${DATABASE_PWD}" --from-literal=keybase="${KEYBASE}"'                    

                    """               
                }
            }

            stage('Build Image') {
                if (RELEASE_TYPE == 'develop' || \
                    RELEASE_TYPE == 'stage' || \
                    RELEASE_TYPE == 'release' ||\
                    RELEASE_TYPE == 'hotfix') {
                    echo 'Build on ' + RELEASE_TYPE
                    echo 'Full Image Name:' + IMAGE_BUILD_FULL_NAME

                    //Image Tag is already set in BuildConfig (need "special" one for HotFix in Release Environment)
                    sh"""
                    oc whoami
                    echo 'oc start-build "helpline-build" --from-repo="." --wait=true --follow -n ${IMAGE_BUILD_OS_PROJECT}'
                    """
                } 
            }
            stage('Image Management') {
                if (RELEASE_TYPE == 'release' || RELEASE_TYPE == 'hotfix') {
                    // This is already set in the beginning configuration section, but could be done here.
                    def SOURCE_TAG = REL_OS_PROJECT + '/' + IMAGE_NAME + ':' + REL_IMAGE_TAG
                    def DEST_TAG = REL_OS_PROJECT + '/' + IMAGE_NAME + ':' + APP_VERSION
                    sh "echo 'oc tag ${SOURCE_TAG} ${DEST_TAG}'"
                } else if (RELEASE_TYPE == 'master') {
                    // This is already set in the beginning configuration section, but could be done here.
                    def SOURCE_TAG = REL_OS_PROJECT + '/' + IMAGE_NAME + ':' + APP_VERSION
                    def DEST_TAG = PRD_OS_PROJECT + '/' + IMAGE_NAME + ':' + APP_VERSION
                    sh "echo 'oc tag ${SOURCE_TAG} ${DEST_TAG}'"
                }
            }
            stage ('Secrets Cleanup') {
                echo 'Delete any secrets that are not needed (maybe build secrets)'

            }
        }
        if (RELEASE_TYPE != 'hotfix') {
            stage('Deploy Application') {
                container('helm') {
                    stage('Initialize Helm') {
                        echo 'Initialize Helm Client and Check tiller access'
                        
                        sh """
                        echo 'helm init --client-only'
                        echo 'helm version --tiller-namespace ${HELM_TILLER_NAMESPACE}'
                        """
                    }
                    stage('Lint Tests') {
                        echo 'Run Helm Lint Test'

                        sh """
                        echo 'helm lint ${HELM_CHART_LOCATION}'
                        """
                    }
                    stage('Helm Versioning') {
                        if (RELEASE_TYPE == 'develop' || RELEASE_TYPE == 'stage') {
                            //Just version the appVersion for clarity, no "real" purpose.
                            def chartYaml = readYaml file: 'helm/helpline/Chart.yaml'
                            HELM_CHART_VERSION = chartYaml.version.toString()
                            def appVersion = chartYaml.appVersion.toString()
                            chartYaml.appVersion = RELEASE_TYPE  +'-'+GIT_SHORT_COMMIT
                            echo 'Current: HELM_CHART_VERSION:'+HELM_CHART_VERSION+'appVersion:'+appVersion

                            sh "rm -f helm/helpline/Chart.yaml"
                            writeYaml file: "helm/helpline/Chart.yaml", data: chartYaml

                        } else if (RELEASE_TYPE == 'master') {
                            //App and Chart Version
                            def chartYaml = readYaml file: 'helm/helpline/Chart.yaml'
                            def valuesYaml = readYaml file: 'helm/helpline/values.yaml'

                            HELM_CHART_VERSION = chartYaml.version.toString()
                            def appVersion = chartYaml.appVersion.toString()
                            def currentImage = valuesYaml.images.apiTag.toString()
                            echo 'Current: HELM_CHART_VERSION:'+HELM_CHART_VERSION+' appVersion:'+appVersion+' currentImage:'+currentImage
                            if (APP_VERSION == "") {
                                error 'No Parsed APP_VERSION for deployment.'
                            } else {
                                chartYaml.appVersion = APP_VERSION
                                valuesYaml.images.apiTag = APP_VERSION
                            }

                            sh "rm -f helm/helpline/values.yaml"
                            sh "rm -f helm/helpline/Chart.yaml"

                            writeYaml file: "helm/helpline/values.yaml", data: valuesYaml
                            writeYaml file: "helm/helpline/Chart.yaml", data: chartYaml


                        } else if (RELEASE_TYPE == 'release'){

                           //App and Chart Version
                            def chartYaml = readYaml file: 'helm/helpline/Chart.yaml'
                            def valuesYaml = readYaml file: 'helm/helpline/values.yaml'

                            HELM_CHART_VERSION = chartYaml.version.toString()
                            def appVersion = chartYaml.appVersion.toString()
                            def currentImage = valuesYaml.images.apiTag.toString()
                            echo 'Current: HELM_CHART_VERSION:'+HELM_CHART_VERSION+' appVersion:'+appVersion+' currentImage:'+currentImage
                            if (APP_VERSION == "") {
                                error 'No Parsed APP_VERSION for deployment.'
                            } else {
                                chartYaml.appVersion = APP_VERSION
                                valuesYaml.images.apiTag = APP_VERSION
                            }

                            sh "rm -f helm/helpline/values.yaml"
                            sh "rm -f helm/helpline/Chart.yaml"

                            writeYaml file: "helm/helpline/values.yaml", data: valuesYaml
                            writeYaml file: "helm/helpline/Chart.yaml", data: chartYaml
                        } 
                        
                    }
                    stage('Package Helm and Push to ChartMuseum'){
                        if(RELEASE_TYPE == 'master') {
                            sh """
                            echo "helm package ${HELM_CHART_LOCATION} -d ${HELM_TGZ_DEST_DIR}"
                            """
                            HELM_TGZ_PACKAGE_FINAL = HELM_CHARTNAME + '-' + HELM_CHART_VERSION + '.tgz'
                            echo 'Helm .tgz Package: ' + HELM_TGZ_PACKAGE_FINAL

                            sh """
                            echo 'curl -u admin:admin -k --data-binary ${HELM_TGZ_PACKAGE_FINAL} http://chartmuseum-chartmuseum.chartmuseum:8080/api/charts'
                            """

                        }
                     }
                    stage ('Deploy with Helm') {
                        //Could make this a "configuration step, and just set all remaining values before a global "deploy"
                        if (RELEASE_TYPE == 'master'){
                            //Set Full path of TGZ
                            //def TGZ_PATH = HELM_TGZ_DEST_DIR + '/' + PACKAGE_NAME 
                            
                            /* Real Code Below
                            sh """
                            helm version --tiller-namespace ${HELM_TILLER_NAMESPACE} \
                            helm upgrade --install ${HELM_RELEASE_NAME_FINAL} \
                            ${TGZ_PATH} \
                            --namespace ${DEPLOY_OS_PROJECT} \
                            --tiller-namespace ${HELM_TILLER_NAMESPACE} \
                            -f ${HELM_YAML_LOCATION_FINAL} \
                            --set image.apiRepository=${DEPLOY_OS_PROJECT}
                            --set image.apiTag=${DEPLOY_IMAGE_TAG}
                            """
                            */
                            
                            echo 'Deploy Production with helm to ' + DEPLOY_OS_PROJECT + ' with tag:' + DEPLOY_IMAGE_NAME
                            sh 'helm --help'
                        } else if (RELEASE_TYPE == 'hotfix') {
                           //No deploy for Helm.  Could deploy into PRD off this (instead of merging to master.  Not sure I like)
                           //Could deploy into Hot Fix environment, build one on the fly, or into Release.
                            echo 'No deploy for HotFix.'
                            
                        } else if (RELEASE_TYPE == 'develop' || RELEASE_TYPE == 'stage' || RELEASE_TYPE == 'release'){
                            echo 'Deploy with helm to ' + DEPLOY_OS_PROJECT + ' with tag:' + DEPLOY_IMAGE_TAG

                            sh """
                            echo 'helm upgrade --install ${HELM_RELEASE_NAME_FINAL} \
                            ${HELM_CHART_LOCATION} \
                            --namespace ${DEPLOY_OS_PROJECT} \
                            --tiller-namespace ${HELM_TILLER_NAMESPACE} \
                            -f ${HELM_YAML_LOCATION_FINAL} \
                            --set images.apiRepository=${DEPLOY_OS_PROJECT} \
                            --set images.apiTag=${DEPLOY_IMAGE_TAG} \
                            '
                            """
                        }
                    }
                }
            }
        }
        stage('Post-Deploy Verification') {
            container('jnlp') {
                if (RELEASE_TYPE == 'master') {
                    echo 'Post Deploy Verfication for Master'
                    sh """
                    echo 'oc -n ${DEPLOY_OS_PROJECT} rollout status deployment api'
                    """
                } else if (RELEASE_TYPE == 'develop'){
                    echo 'Post Deploy Verfication for Develop'
                } else if (RELEASE_TYPE == 'stage'){
                    echo 'Post Deploy Verfication for Stage'
                } else if (RELEASE_TYPE == 'release'){
                    echo 'Post Deploy Verfication for Release'
                } else if (RELEASE_TYPE == 'hotfix'){
                    echo 'Post Deploy Verfication for HotFix'
                } 
            }
        }    
        stage('Post-Deploy Jobs') {
            //Could be run by Helm as Jobs, or by OpenShift using 'oc apply'
            container('jnlp') {
                if (RELEASE_TYPE == 'master') {
                    echo 'Post Deploy Jobs for Master'
                    sh """
                    echo 'oc apply -f k8/post-upgrade-job.yml --namespace ${DEPLOY_OS_PROJECT}'
                    """
                } else if (RELEASE_TYPE == 'develop'){
                    echo 'Post Deploy Jobs for Develop'
                } else if (RELEASE_TYPE == 'stage'){
                    echo 'Post Deploy Jobs for Stage'
                } else if (RELEASE_TYPE.contains(REL_TAG_FILTER) && GIT_COMMIT_HEAD_TAG.contains(REL_TAG_FILTER)){
                    echo 'Post Deploy Jobs for Release'
                } else if (RELEASE_TYPE.contains(HOT_TAG_FILTER) && GIT_COMMIT_HEAD_TAG.contains(HOT_TAG_FILTER)){
                    echo 'Post Deploy Jobs for HotFix'
                } 
            }
        }                
        stage('JIRA') {
            container('jnlp') {
                if (RELEASE_TYPE == 'master') {
                    echo 'JIRA Update of Issue/Ticket that its available in Production'
                } else if (RELEASE_TYPE == 'develop'){
                    echo 'No Update'
                } else if (RELEASE_TYPE == 'stage'){
                    echo 'No Update'
                } else if (RELEASE_TYPE.contains(REL_TAG_FILTER) && GIT_COMMIT_HEAD_TAG.contains(REL_TAG_FILTER)){
                    echo 'JIRA Update of Issue/Ticket that its available for Testing'
                } else if (RELEASE_TYPE.contains(HOT_TAG_FILTER) && GIT_COMMIT_HEAD_TAG.contains(HOT_TAG_FILTER)){
                    echo 'No Update'
                } 
            }
        }
    }
}
